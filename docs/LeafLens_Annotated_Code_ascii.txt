# LeafLens Annotated Code Guide

This document explains the core LeafLens codebase end-to-end: what each module does, how data flows from the camera/gallery to the FastAPI inference server, and how results render in the app. It includes curated code excerpts with commentary, guidance on configuration, and troubleshooting tips.

Use this as the onboarding reference and a practical maintenance guide.

---

1. Architecture Overview

- Client: React Native + Expo app (Navigation, Auth via Supabase, image capture/pick, upload to server, render results, local history).
- Server: FastAPI service loading a PyTorch model from `best_model.pth`, providing a `/predict/` endpoint returning `top1` and `topK`.
- Networking: `fetch` with multipart `FormData`, timeouts via `AbortController`, base URL from `app.json` -> `extra.API_BASE_URL`.
- Persistence: `AsyncStorage` stores recent diagnoses and Supabase sessions.

High-level flow: Home -> take photo/pick -> upload -> receive JSON -> map to friendly disease info -> Result screen -> optional history panel.

---

2. App Bootstrap

File: `App.tsx`

Purpose: Initialize user settings (language) and render the app's navigation tree.

```tsx
export default function App() {
  const [ready, setReady] = React.useState(false);
  React.useEffect(() => {
    (async () => {
      const s = await getSettings();
      setI18nLanguage(s.language as any);
      setReady(true);
    })();
  }, []);

  if (!ready) return null;
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <RootNavigation />
      <StatusBar style="auto" />
    </GestureHandlerRootView>
  );
}
```

Notes:
- Defers rendering until settings are loaded to avoid flicker.
- Wraps in `GestureHandlerRootView` to support swipe/drag gestures.

File: `index.ts`

```ts
import 'react-native-gesture-handler';
import { registerRootComponent } from 'expo';
import App from './App';
registerRootComponent(App);
```

Notes:
- Ensures proper Expo + RN setup across Expo Go and standalone builds.

---

3. Configuration

File: `app.json`

```json
{
  "expo": {
    "name": "LeafLens",
    "extra": {
      "API_BASE_URL": "http://192.168.29.184:8000",
      "SUPABASE_URL": "https://...supabase.co",
      "SUPABASE_ANON_KEY": "..."
    },
    "plugins": [[
      "react-native-fast-tflite",
      { "enableAndroidGpuLibraries": true, "enableCoreMLDelegate": true }
    ]]
  }
}
```

Notes:
- `extra.API_BASE_URL` drives the client -> server endpoint.
- Set these per environment; do not commit secrets.

File: `src/config/api.ts`

```ts
export function getDefaultBaseUrl() {
  return Platform.OS === 'android' ? 'http://10.0.2.2:8080' : 'http://127.0.0.1:8080';
}

export function resolveBaseUrl(override?: string) {
  const anyConst = Constants as any;
  const fromExpoConfig = anyConst?.expoConfig?.extra?.API_BASE_URL as string | undefined;
  // ...
  return fromExtra || getDefaultBaseUrl();
}
```

Why it matters:
- Handles emulator/simulator localhost differences.
- Allows override and future `MODEL_NAME` query via `resolveModelQuery()`.

---

4. Navigation

File: `src/navigation/index.tsx`

- Provides stack routes gated by auth state.
- Applies dark/light theme based on system or user settings.

```tsx
export type RootStackParamList = {
  Home: undefined;
  Result: { label: string; probability: number; topK?: {label:string; probability:number}[]; imageUri?: string };
  // ...
};

function StackContent() {
  const { user } = useAuth();
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {user ? (
        <>
          <Stack.Screen name="Home" component={HomeScreen} />
          <Stack.Screen name="Result" component={ResultScreen} />
          {/* other app screens */}
        </>
      ) : (
        <>
          <Stack.Screen name="Landing" component={LandingScreen} />
          <Stack.Screen name="Login" component={LoginScreen} />
          {/* auth screens */}
        </>
      )}
    </Stack.Navigator>
  );
}
```

Notes:
- Deep link `ResetPassword` handled via `linking` config.

---

5. Authentication

File: `src/services/supabaseClient.ts`

```ts
export const supabase = createClient(SUPABASE_URL || '', SUPABASE_ANON_KEY || '', {
  auth: {
    persistSession: true,
    storage: {
      getItem: (key) => AsyncStorage.getItem(key),
      setItem: (key, val) => AsyncStorage.setItem(key, val),
      removeItem: (key) => AsyncStorage.removeItem(key),
    },
  },
});

export async function getEmailByUsername(username: string) {
  const { data, error } = await (supabase as any).rpc('get_email_by_username', { p_username: username.trim() });
  if (error) { console.warn('getEmailByUsername error:', error); return null; }
  return (data as string) || null;
}
```

File: `src/state/AuthContext.tsx`

- Owns auth state, login/register/logout, Google OAuth, reset password.
- Cleans legacy keys and listens to Supabase `onAuthStateChange`.

```tsx
const { data: sub } = supabase.auth.onAuthStateChange(async (_event, session) => {
  if (session?.user) {
    const derivedUsername = (session.user.user_metadata as any)?.username
      || session.user.email?.split('@')[0]
      || 'user';
    setUser({ username: derivedUsername, email: session.user.email || '' });
  } else {
    setUser(null);
  }
});
```

Why it matters:
- Centralizes all auth behavior; UI subscribes via `useAuth()`.

---

6. Home Screen (Capture/Upload)

File: `src/screens/HomeScreen.tsx`

Purpose: Capture or pick a photo, call diagnosis, navigate to `Result`, and store in local history.

```tsx
const takePhoto = async () => {
  const perm = await ImagePicker.requestCameraPermissionsAsync();
  if (!perm.granted) return Alert.alert(t('permissionRequired'), t('allowCameraAccess'));
  const res = await ImagePicker.launchCameraAsync({ quality: 1 });
  if (!res.canceled) {
    const uri = res.assets[0].uri;
    setBusy(true);
    const json = await diagnoseImage(uri, {});
    await handleResultNavigate(uri, json);
  }
};
```

Result normalization:

```tsx
const handleResultNavigate = async (imageUri: string, json: any) => {
  let topK = [] as { label: string; probability: number }[];
  if (Array.isArray(json?.topK)) { /* shape A */ }
  else if (Array.isArray(json?.predictions)) { /* shape B */ }
  else if (json?.predictions && typeof json.predictions === 'object') { /* dict shape */ }
  if (!topK.length && json?.label) { /* fallback single */ }
  if (!topK.length) topK = [{ label: 'Unknown', probability: 0 }];
  const top1 = json?.top1 ? {/* map */} : topK[0];
  navigation.navigate('Result', { label: top1.label, probability: top1.probability, topK, imageUri });
  addDiagnosis({ label: top1.label, probability: top1.probability, imageUri }).catch(() => {});
};
```

Notes:
- Supports multiple API response shapes.
- Adds recent diagnosis with cap to last 5.

---

7. Result Screen (Display)

File: `src/screens/ResultScreen.tsx`

Purpose: Visualize output with confidence, show top-3 alternatives, and curated info (symptoms/treatment).

```tsx
{imageUri && <Image source={{ uri: imageUri }} style={{ width: '100%', height: 240 }} />}
<Text style={{ fontSize: 24, fontWeight: '800' }}>{info?.name ?? label}</Text>
<ConfidenceBar value={probability} />
{topK && topK.length > 1 && (
  <Card>
    <Text>{t('topPredictions')}</Text>
    {topK.slice(0, 3).map((r, i) => (
      <Text key={i}>#{i + 1} {(getDiseaseInfo(r.label)?.name ?? r.label)} - {(r.probability * 100).toFixed(1)}%</Text>
    ))}
  </Card>
)}
```

Notes:
- For "Unknown" cases, the Home normalization ensures top predictions aren't misleading.

---

8. History Storage

File: `src/services/history.ts`

```ts
export async function addDiagnosis(item: Omit<DiagnosisItem, 'id' | 'at'>) {
  const all = await getHistory();
  const next: DiagnosisItem = { id: `${Date.now()}`, at: Date.now(), ...item };
  const merged = [next, ...all].slice(0, 5);
  await AsyncStorage.setItem(KEY, JSON.stringify(merged));
}
```

Notes:
- Keeps recent list short for performance and clarity.

---

9. Banana Knowledge Base

File: `src/data/bananaInfo.ts`

- Maps model labels (and aliases) to user-friendly names, symptoms, and treatment guidance.

```ts
export function getDiseaseInfo(label: string): DiseaseInfo | null {
  if (bananaDiseaseLibrary[label]) return bananaDiseaseLibrary[label];
  const n = norm(label);
  const key = aliases[n];
  if (key && bananaDiseaseLibrary[key]) return bananaDiseaseLibrary[key];
  // basic title-case heuristic
  const guess = label.split(/[\_\-\s]+/).map(...).join(' ');
  if (bananaDiseaseLibrary[guess]) return bananaDiseaseLibrary[guess];
  return null;
}
```

Notes:
- Decouples model taxonomy from UI text.

---

10. Networking and Upload Robustness

File: `src/services/cloudInference.ts`

Purpose: Send image to FastAPI using multipart form data, with timeouts and retries.

Key features:
- Default 120s timeout (`timeoutMs = 120_000`).
- Two attempts total, each with fresh `AbortController` and `FormData`.
- Port fallback between `8080` and `8000` and endpoint variants with/without trailing slash.
- Friendly error messages for network failures.

```ts
export async function diagnoseImage(imageUri: string, opts: DiagnoseOptions = {}) {
  const { baseUrl = resolveBaseUrl(), endpointPath = '/predict/', timeoutMs = 120_000 } = opts;
  const buildForm = () => { const f = new FormData(); f.append('file', { uri: imageUri, name: 'leaf.jpg', type: 'image/jpeg' } as any); return f; };
  const tryUrls = /* derive base + port fallbacks */;
  const endpointVariants = [ `${endpointPath}${resolveModelQuery()}`, endpointPath.replace(/\/$/, '') ];
  for (let attempt = 1; attempt <= 2; attempt++) {
    for (const b of tryUrls) for (const ep of endpointVariants) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try { const res = await fetch(`${b}${ep}`, { method: 'POST', headers: { Accept: 'application/json' }, body: buildForm(), signal: controller.signal });
        if (!res.ok) { /* collect lastErrorText and continue */ }
        return await res.json();
      } catch (e) { /* save error and continue */ } finally { clearTimeout(id); }
    }
  }
  throw new Error('All endpoints failed');
}
```

Notes:
- Fresh `FormData` avoids reused stream issues in RN.
- Extended timeout and retry improve reliability on slower networks.

---

11. FastAPI Server

File: `banana_api/app.py`

- CORS enabled for development.
- Serves `/` health, optional `/ui` static view, and `/predict/` for inference.

```py
@app.post("/predict/")
async def predict_image_endpoint(file: UploadFile = File(...)):
    contents = await file.read()
    image = Image.open(io.BytesIO(contents))
    confidences = inference.predict_image(MODEL, image)
    sorted_items = sorted(confidences.items(), key=lambda kv: kv[1], reverse=True)
    topK = [{"label": k, "probability": float(v)} for k, v in sorted_items]
    top1 = topK[0] if topK else {"label": "Unknown", "probability": 0.0}
    return {"top1": top1, "topK": topK, "predictions": topK}
```

File: `banana_api/inference.py`

- Loads `HybridCNNViT` weights and runs a simple transform + softmax.

```py
DEVICE = torch.device("cpu")
CHECKPOINT_PATH = os.environ.get("MODEL_PATH", "best_model.pth")

def load_model():
    loaded_model = HybridCNNViT(NUM_CLASSES).to(DEVICE)
    checkpoint = torch.load(CHECKPOINT_PATH, map_location=DEVICE)
    loaded_model.load_state_dict(checkpoint['model_state_dict'])
    loaded_model.eval()
    return loaded_model
```

Notes:
- For Docker, use `MODEL_PATH`/`MODEL_URL` env vars.

---

12. End-to-End Data Flow

1) Home: user captures/picks -> `diagnoseImage(uri)`
2) `cloudInference`: builds `FormData` -> POST `/predict/` with timeout/retry
3) Server: loads model once -> predict -> returns `top1` + `topK`
4) Home: normalizes -> navigate to `Result`
5) Result: render image, confidence, alternatives, curated info
6) History: store last 5 in `AsyncStorage`

---

13. Configuration Tips

- API base URL: ensure mobile device and server are on the same network; update `app.json -> extra.API_BASE_URL`.
- Android emulator uses `10.0.2.2:<port>` for host machine.
- Consider `.env` + `app.config.ts` for per-env config in production.

---

14. Troubleshooting

- "Network request failed":
  - Check server is reachable from device IP and port.
  - Verify Windows firewall allows inbound on the selected port.
  - Confirm Docker port mapping if using containers.
- Timeouts:
  - Increase `timeoutMs` in `diagnoseImage` for very large images.
  - Use server logs (Uvicorn) to confirm request arrival.
- Wrong labels:
  - Verify pre-processing matches training (`Resize(224,224)`, normalization).
  - Update `bananaInfo` aliases to map model outputs to friendly names.

---

15. Extending the App

- Offline inference: add a TFJS model or TFLite; wire a local `modelService` with the same return shape as `/predict/`.
- Confidence gating: client can hide `topK` below a threshold or label as "No disease found".
- Analytics: add event logging for diagnosis events.

---

16. Security Considerations

- Do not commit Supabase anon keys for production; use environment-specific configs and secure distribution.
- Lock down CORS in FastAPI to known origins for production.

---

17. Testing

- Unit test `bananaInfo` mappings and `history` logic in isolation.
- Integration test upload with a few fixture images against `/predict/`.

---

18. Build & Run

Client (Expo):

```
# Ensure server is running and API_BASE_URL points to it
npm install
npm start
```

Server (FastAPI):

```
# Python 3.10+ and dependencies from banana_api/requirements.txt
cd banana_api
uvicorn app:app --host 0.0.0.0 --port 8000
```

Docker (server): see `banana_api/README-Docker.md`.

---

19. Key Design Choices

- Simple JSON schema: `top1`, `topK`, and backward-compatible `predictions` array or dict.
- Robust upload: retries + long timeout + endpoint variants.
- Curated info decoupled from model outputs via alias mapping.

---

20. Appendix: Selected Excerpts

A) Abortable fetch with timeout

```ts
const controller = new AbortController();
const id = setTimeout(() => controller.abort(), timeoutMs);
try { /* fetch */ } finally { clearTimeout(id); }
```

B) History ring buffer

```ts
const merged = [next, ...all].slice(0, 5);
await AsyncStorage.setItem(KEY, JSON.stringify(merged));
```

C) Model URL override (server)

```py
CHECKPOINT_PATH = os.environ.get("MODEL_PATH", "best_model.pth")
CHECKPOINT_URL = os.environ.get("MODEL_URL")
```

---

21. UI Components

File: `src/ui/components.tsx`

- Shared building blocks: `Screen`, `Card`, `PrimaryButton`, `Input`, `ConfidenceBar`, `SectionCard`, etc.

```tsx
export const PrimaryButton: React.FC<{ title: string; onPress: () => void; disabled?: boolean; icon?: React.ReactNode }>
  = ({ title, onPress, disabled, icon }) => (
  <TouchableOpacity activeOpacity={0.9} onPress={onPress} disabled={disabled} style={{ borderRadius: 12, overflow: 'hidden', opacity: disabled ? 0.6 : 1 }}>
    <LinearGradient colors={[colors.primary, colors.primaryDark]} start={{ x: 0, y: 0 }} end={{ x: 1, y: 1 }} style={{ padding: spacing(2), alignItems: 'center' }}>
      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
        {icon}
        <Text style={{ color: 'white', fontWeight: '700', fontSize: 16 }}>{title}</Text>
      </View>
    </LinearGradient>
  </TouchableOpacity>
);
```

Why it matters:
- Consistent styling and interactions across screens; easy to theme.

---

22. Theme System

File: `src/ui/theme.ts`

- Central colors, spacing, and shadow. `applyThemeMode()` mutates the `colors` object so imports see live updates.

```ts
export const colors: ColorPalette = { ...lightPalette };
export function applyThemeMode(mode: 'light' | 'dark') {
  const palette = mode === 'dark' ? darkPalette : lightPalette;
  Object.assign(colors, palette);
}
export const spacing = (n: number) => n * 8;
```

Why it matters:
- Enables instant dark/light switching without rerender thrash.

---

23. App Header

File: `src/ui/AppHeader.tsx`

- Compact top bar with logo and quick navigation.

```tsx
export default function AppHeader({ title, onHome, onCommunity, onHistory, onProfile }: Props) {
  return (
    <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: colors.bgAlt, paddingHorizontal: spacing(2), paddingVertical: spacing(1.5), borderRadius: 16 }}>
      <View style={{ flexDirection: 'row', alignItems: 'center', gap: 10 }}>
        <LogoMark size={28} />
        <Text style={{ color: colors.text, fontWeight: '800', fontSize: 20 }}>{title || t('brand')}</Text>
      </View>
      <View style={{ flexDirection: 'row', gap: 16 }}>
        <Text onPress={onHome}><Ionicons name="home-outline" size={22} color={colors.text} /></Text>
        <Text onPress={onCommunity}><Ionicons name="people-outline" size={22} color={colors.text} /></Text>
        <Text onPress={onHistory}><Ionicons name="time-outline" size={22} color={colors.text} /></Text>
        <Text onPress={onProfile}><Ionicons name="person-circle-outline" size={22} color={colors.text} /></Text>
      </View>
    </View>
  );
}
```

---

24. i18n

File: `src/i18n.ts`

- Simple dictionary-based localization for English, Hindi, and Marathi.

```ts
export type Language = 'English' | 'Hindi' | 'Marathi';
let current: Language = 'English';
const dict: Record<Language, Record<string, string>> = { /* ... */ };
export function setLanguage(l: Language) { current = l; }
export function t(key: string) { return (dict[current] && dict[current][key]) || key; }
```

Tips:
- Add keys first in English; mirror into other languages gradually.

---

25. Settings Service

File: `src/services/settings.ts`

- Loads/saves `AppSettings` in `AsyncStorage`; includes a tiny pub-sub to notify listeners on change.

```ts
export async function updateSettings(patch: Partial<AppSettings>): Promise<AppSettings> {
  const cur = cache || (await getSettings());
  const next = { ...cur, ...patch } as AppSettings;
  cache = next;
  await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(next));
  notify(next);
  return next;
}
```

Why it matters:
- Navigation applies theme mode reactively via `subscribeSettings`.

---

26. Auth Screens

Files: `src/screens/LoginScreen.tsx`, `src/screens/RegisterScreen.tsx`, `src/screens/ResetPasswordScreen.tsx`

- Showcase patterns for form inputs, validation, and calling `AuthContext` helpers.

```tsx
const onLogin = async () => {
  const result = await login(identifier.trim().toLowerCase(), password);
  if (!result.ok) { /* friendly alerts incl. resend verification */ }
};
```

Notes:
- Google OAuth via Supabase PKCE is one tap in both screens.

---

27. Community Feature

Files: `src/screens/CommunityScreen.tsx`, `src/services/community.ts`

- Minimal forum with categories, local fallback storage, and optional Supabase backend.

```ts
export async function listPosts(): Promise<CommunityPost[]> {
  try {
    const { data, error } = await supabase.from('posts').select('id,title,content,category,created_at,author_id,author_name').order('created_at', { ascending: false });
    if (!error && data) { /* normalize and return */ }
  } catch {}
  return storageGet();
}
```

Why it matters:
- Demonstrates resilient data access (online/offline) and basic CRUD.

---

28. History Screen

File: `src/screens/HistoryScreen.tsx`

- Reads `AsyncStorage` history and allows clearing.

```tsx
const sub = navigation.addListener('focus', async () => setItems(await getHistory()));
```

---

29. Profile & Settings Screens

Files: `src/screens/ProfileScreen.tsx`, `src/screens/SettingsScreen.tsx`

- Profile shows user info and provides logout; Settings changes theme/language and exposes utilities.

```tsx
<TouchableOpacity onPress={async () => { await logout(); }} style={{ backgroundColor: '#EF4444' }}>
  <Text style={{ color: 'white', fontWeight: '800' }}>{t('logout')}</Text>
</TouchableOpacity>
```

---

30. Shims for Expo

Files: `src/shims/expo-camera.js`, `src/shims/react-native-fs.js`

- Provide minimal modules so third-party libraries bundle under Expo managed workflow.

```js
// expo-camera shim
module.exports = { Camera: function Camera() { throw new Error('expo-camera is not available in this build; use ImagePicker'); } };
```

```js
// react-native-fs shim
module.exports = { readFile: async (uri) => await FileSystem.readAsStringAsync(uri, { encoding: 'base64' }) };
```

---

31. Health Check Utility

File: `src/services/health.ts`

```ts
export async function pingApi(): Promise<boolean> {
  try { const base = resolveBaseUrl(); const res = await fetch(`${base}/`, { method: 'GET' }); return res.ok; } catch { return false; }
}
```

Usage:
- Can be called on app start to warn if server is unreachable.

---

32. Model Service Stubs

File: `src/services/modelService.ts`

- Provides a future path for fully offline inference; currently returns a stable stub result and loads labels.

```ts
export async function runInference(_imageUri: string): Promise<InferenceBundle> {
  const top1 = { label: classLabels[0] || 'Healthy', probability: 0.5 };
  return { top1, topK: [top1] };
}
```

Notes:
- Swap to TFJS/TFLite/ONNX later; keep the return shape consistent with `/predict/`.

---

33. Mock API (Dev)

File: `server/mock-api/index.js`

- Placeholder for a local Node mock if needed; can return canned predictions for UI development.

---

34. Service Barrel

File: `src/services/index.ts`

- Aggregates service exports; currently points health + a placeholder tflite service.

```ts
export * from './health';
export * from './tfliteService';
```

---

35. Next Steps

- Migrate offline inference from stub to a concrete backend (TFJS or TFLite) and gate via Settings -> Offline Mode.
- Add instrumented logging for upload timings to improve retry/backoff logic.
- Write unit tests for `settings`, `bananaInfo`, and `community` helpers.

---

36. Build & Tooling Config

Files: `metro.config.js`, `babel.config.js`, `package.json`

- Metro (bundler) extensions for ML assets, Babel preset for Expo, and app scripts/dependencies.

`metro.config.js`

```js
const { getDefaultConfig } = require('expo/metro-config');
const base = getDefaultConfig(__dirname);
module.exports = {
  ...base,
  resolver: {
    ...(base.resolver || {}),
    assetExts: [
      ...((base.resolver && base.resolver.assetExts) || []),
      'bin',
      'tflite'
    ],
  },
};
```

Why it matters:
- Allows bundling `.tflite` (and custom `.bin`) model files when moving to on-device inference.

`babel.config.js`

```js
module.exports = function (api) {
  api.cache(true);
  return { presets: ['babel-preset-expo'] };
};
```

Notes:
- Keeps transforms aligned with Expo SDK; add plugins here if needed later.

`package.json`

```json
{
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "~54.0.13",
    "react": "19.1.0",
    "react-native": "0.81.4",
    "@supabase/supabase-js": "^2.75.1",
    "react-native-fast-tflite": "^1.6.1"
  }
}
```

Tips:
- When adding native ML libs (e.g., TFLite, ONNX), prefer Expo Dev Builds and ensure Metro asset extensions include model formats.
